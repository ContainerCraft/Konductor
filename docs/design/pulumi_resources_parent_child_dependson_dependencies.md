Pulumi Parent-Child Relationships and Dependency Mechanics

1. Parent vs. dependsOn

Pulumi provides two ways to express relationships between resources: parent-child relationships and explicit dependencies. The parent option establishes a hierarchy (one resource is a child of another), while the dependsOn option forces an ordering without a hierarchy. In general, you should use parent to model logical ownership and use dependsOn only when necessary for ordering that Pulumi cannot deduce automatically ￼ ￼.
	•	When to use parent: Use parent when a resource is logically owned by another (especially within ComponentResources). For example, an Azure Resource Group can be the parent of resources deployed inside it, or a VPC resource can be the parent of its subnet resources. Parenting a resource implicitly creates a dependency (the parent is created before the child) and also groups them in the Pulumi output for clarity ￼ ￼. Child resources inherit certain settings from the parent (like the provider configuration and protection) and the parent won’t be deleted before its children ￼. A best practice is to always set parent for resources inside a custom component or module, to reflect encapsulation. For example:

const resourceGroup = new azure.resources.ResourceGroup("myRG");
const sqlServer = new azure.sql.Server("myServer", { /* ... */ }, { parent: resourceGroup });
const database = new azure.sql.Database("myDb", { /* ... */ }, { parent: sqlServer });

In this snippet, the resource group is the parent of the SQL server, and the server is parent of the database. This not only ensures the group exists before the server, but also makes the hierarchy clear (e.g., Pulumi previews will show the database nested under the server) ￼ ￼. Do not use parent merely to enforce ordering when there isn’t a logical ownership; the Pulumi docs warn that parenting a resource to an unrelated custom resource can lead to undefined behavior ￼.

	•	When to use dependsOn: Use dependsOn to explicitly declare a dependency when Pulumi’s normal dependency inference isn’t sufficient ￼. Pulumi automatically tracks most dependencies: if resource B uses an output property of resource A, Pulumi knows B depends on A and will create A first ￼. However, sometimes a resource needs to wait for another even if there’s no direct output-input link. Common cases include external processes or ordering requirements (e.g. waiting for an initialization script, or resources that only become consistent after some time). In those cases, dependsOn can be added to ensure the correct order ￼. For example, if you create an S3 BucketObject using a literal bucket name, Pulumi might not know it must create the Bucket first. You can fix that with dependsOn:

const bucket = new aws.s3.Bucket("myBucket");
// This object uses the bucket Output, so Pulumi knows to create the bucket first:
const obj1 = new aws.s3.BucketObject("obj1", { bucket: bucket.bucket, source: /*...*/ });
// This object uses a raw name string, so we explicitly depend on the bucket:
const obj2 = new aws.s3.BucketObject("obj2", { bucket: "myBucket", source: /*...*/ },
    { dependsOn: [bucket] });

In the first case, Pulumi sees obj1.bucket comes from bucket.bucket (an output), so it will always create the bucket before obj1 ￼ ￼. In the second case, using a plain string would not create a dependency, but adding { dependsOn: [bucket] } tells Pulumi to wait for the bucket ￼. Likewise, if you have resources that are not directly connected in code (for example, a DNS record that should be created after an external service is deployed), you can use dependsOn to sequence them.

	•	When not to use these options: Avoid using dependsOn unless you truly have a dependency that Pulumi cannot infer ￼. Overusing dependsOn for every resource (“just in case”) is an anti-pattern, as it needlessly serializes operations (more on that below). Instead, pass outputs where possible so Pulumi knows the dependency naturally. Similarly, don’t misuse parent to force ordering if there’s no ownership relationship ￼. For example, don’t set an EC2 instance as the parent of an RDS database just to make the DB create first – they are unrelated resources, so use an output or dependsOn if one truly must wait for the other. In summary, prefer parent for logical grouping (especially inside components) and use dependsOn sparingly for extra ordering constraints ￼. Pulumi experts note that they “use parent 95% of the time” and use dependsOn “never, unless it’s needed to get stuff working” ￼.

2. Dependency Graph and Ordering

Pulumi builds a directed acyclic graph (DAG) of resources to determine create/update/destroy order. Each resource is a node in the graph. Edges (dependencies) are added automatically when a resource’s input comes from another resource’s output. Additional edges come from any explicit dependsOn relationships ￼. The resulting graph guides the deployment engine in deciding what can proceed in parallel and what must wait.

Deploy (Create/Update) Ordering: By default, Pulumi will operate on resources in parallel whenever it’s safe. The engine can perform up to 16 resource operations concurrently by default ￼. This means if you have many independent resources, your deployment is fast – Pulumi will create them all at once (subject to the parallelism limit). If there are dependencies, Pulumi will respect them: a resource will not be created until all of the resources it depends on are created first ￼. For example, if resource B depends on A (via output or dependsOn), Pulumi ensures A’s creation is finished before starting B. In practice, the Pulumi CLI shows a dependency graph during preview and then executes a topological sort of that graph. Resources without dependencies may create in any order or in parallel, while anything with an edge from another will wait for that prerequisite ￼. This applies not just to creation but also to updates – if B depends on A, an update to A (or A’s replacement) will occur before updating B.

Destroy (Deletion) Ordering: When destroying or deleting resources, Pulumi does the reverse. It will delete resources in the correct order, such that no resource is deleted before something that depends on it ￼. For instance, if A must exist before B can be created, then on teardown B will be deleted before A. Parent-child relationships also influence this: Pulumi will delete child resources before deleting their parent. This prevents a parent from disappearing while a child still needs it (e.g., a parent cluster won’t be deleted until all child nodes are gone). Pulumi’s engine automatically computes this deletion order from the same dependency graph (just inverted). As the docs state, the dependsOn option ensures that creation, update, and deletion are done in the correct order ￼, so any explicit dependencies you add also apply in reverse for deletes.

How Dependencies Affect Parallelization: Dependencies naturally limit parallel execution. Pulumi tries to perform operations in parallel up to the set --parallel limit (16 by default) ￼, but any chain of dependencies will be executed sequentially along that chain. If you over-constrain resources with dependsOn or by structuring everything as parent-child, you reduce concurrency. For example, imagine 10 independent resources; Pulumi could create many of them simultaneously. But if you needlessly add dependsOn links between each (“daisy-chaining” them), you force Pulumi to do them one by one, slowing the deployment. The key is to express only real dependencies – this ensures correct ordering and maximizes parallel work. Pulumi’s engine is designed to run operations in parallel “whenever possible” and only wait when an output of one is needed by another ￼. Thus, correct use of dependencies can improve speed by not blocking unrelated resources.

Ensuring Correct Order Without Over-Constraining: The best strategy is to rely on Pulumi’s automatic dependency tracking as much as possible. That means passing references (IDs, ARNs, names, etc.) from one resource to another rather than using static values or manual delays. For example, pass a database’s connection string output to a VM’s configuration so that Pulumi knows the VM setup depends on the database being ready. If you find you have an ordering requirement that isn’t captured by an output, consider if you can restructure your code. Often introducing a ComponentResource can help sequence operations internally without adding global dependencies. For instance, one Stack Overflow solution suggests wrapping the steps in a Component so that you can pass required inputs in and have the component produce outputs, thereby enforcing an order of operations inside the component ￼. This is preferable to doing work inside an apply or using arbitrary dependsOn everywhere. In cases where you truly need an explicit ordering (e.g., run a configuration script after a cluster is created), use dependsOn on that script resource or automation resource. Pulumi also offers the ability to orchestrate steps outside of the Pulumi program (for example, using CI/CD to run pulumi up for Stack A, then Stack B). But within a single Pulumi stack, you should rarely need to micro-manage ordering beyond letting the graph handle it.

Finally, note that you should avoid creating resources inside an Output .apply callback, as this circumvents Pulumi’s normal graph tracking. All resources should be declared in the main program execution so that Pulumi knows about them. Creating resources imperatively in a callback (after some value is resolved) is not allowed and will cause errors ￼. Instead, if you have a sequence like “wait for X’s output, then create Y,” either use dependsOn or structure it so Y directly uses X’s output as an input (making the dependency implicit). This way, Pulumi can still see the relationship and include Y in the graph with a dependency edge to X.

3. Circular Dependencies

A circular dependency occurs when two (or more) resources each depend on the other, forming a cycle that Pulumi (and underlying providers) cannot resolve. In Pulumi, true circular dependencies are generally caught by the programming model – you simply cannot code a scenario where resource A’s definition relies on resource B’s output while simultaneously resource B relies on A (one of them won’t exist yet, causing a runtime error in your Pulumi program). For example, if you try to write:

const frontend = new aws.s3.Bucket("frontend");
const api = new aws.apigateway.RestApi("api", { siteUrl: frontend.bucketDomainName });
frontend.websiteEndpoint = api.url; // (pseudo-code: trying to set front-end depends on API)

This is not valid code (and conceptually creates a cycle: front-end needs API’s URL, and API needs front-end’s URL). Pulumi will not allow you to reference a resource that isn’t created yet, so you’ll catch most circular dependencies during development (e.g., a variable will be undefined). A real-world example from the Pulumi blog describes a front-end and an API that need each other’s addresses: the front-end needs the API endpoint for calls, and the API needs the front-end’s URL for allowed origins (CORS) ￼. You can’t create both simultaneously because each waits on the other.

Identifying Circular Dependencies: If you somehow set up a cycle via explicit dependsOn (or a misconfigured parent), Pulumi will detect it when constructing the dependency graph. The preview will error out with a message about a cycle, and no resources will be created. Common signs are Pulumi preview hanging or errors indicating resource X depends on Y which depends on X. In practice, most circular issues arise from logic outside Pulumi’s normal output tracking (since outputs can’t form a cycle). They typically involve two resources that each require information from the other that isn’t available until after creation. If you encounter an unexplained deadlock or a provider error about dependency cycles, examine your resource relationships for loops.

Common Causes:
	•	Bi-directional configurations: As described, two services that need each other’s endpoints or IDs. The Ping/Pong serverless example in Pulumi’s blog shows AWS Lambda functions that invoke each other – each function’s environment needed the other’s name, forming a cycle ￼.
	•	Mutual security group rules (AWS): For instance, Security Group A allows ingress from Security Group B, and B allows ingress from A. If you create both SGs with each other’s IDs in the rules in one go, you have a circular dependency at the AWS level. CloudFormation/Terraform and Pulumi all flag this as a cycle.
	•	Nested cloud resources that reference each other: The Azure Application Gateway is a good example. An Application Gateway needs an HTTP listener configuration as part of its definition, but the listener in turn references the Gateway’s frontend IP configuration. Because the Azure API expects them together, modeling this in Pulumi can appear circular (gateway needs listener, listener needs gateway) ￼ ￼.
	•	Cross-stack references in two directions: If Stack A exports something Stack B needs, and Stack B (or something it exports) is also needed by Stack A, you have a circular dependency across stacks. Pulumi won’t automatically coordinate stack deployments, so this situation can lead to inconsistent or stale data if not handled carefully (though it’s more of a process issue than a Pulumi engine issue).

Techniques to Break Circular Dependencies: The general strategy is to break the loop by introducing an intermediate step or a placeholder value so one side can be created first. Some techniques include:
	•	Deploy in phases: Create one resource first without the dependent configuration, then update it after the second resource is created. The Pulumi team suggests doing two sequential deployments to handle circular deps ￼. In the Ping/Pong Lambda example, the solution was to deploy one function with a dummy opponent name, then deploy again with the real name once the other function existed ￼ ￼. Concretely, you can use pulumi.StackReference to get the output of the first deployment of Resource A while creating Resource B, then update A. This requires running pulumi up twice, but it resolves the cycle. Pulumi’s blog demonstrates this approach step-by-step for the serverless ping-pong example ￼ ￼. Similarly, for Azure Application Gateway, one workaround is to create the gateway with minimal configuration in one update, then add the listeners and routing rules in a follow-up update once the gateway exists (breaking the circular definition) ￼.
	•	Use explicit dependsOn and manual steps: In some scenarios, you can manually orchestrate so that one resource is fully created before the other. For the AWS security group example, you could create SG A first (with no reference to B), then in a later step or deployment, create SG B referencing A and update A’s rules to reference B. Essentially, one side of the connection is established at a time. In Pulumi, you might implement this by separating the rules into their own resources that depend on both SGs (ensuring both SGs exist first). Another trick is to create one SG’s rule with a placeholder (like 0.0.0.0/0 temporarily) and then update it to the specific SG after both are present – though that requires two updates as well.
	•	Introduce an intermediate resource or configuration: Sometimes you can break a cycle by using an intermediary. For example, if two resources need to exchange an ID, perhaps have one write to a database or Parameter Store that the other reads from instead of directly referencing each other. This is more of an architectural change, but it can remove direct cyclic dependence.
	•	For cross-stack cyclic references: Redesign so that the dependency is one-way, or merge the stacks if appropriate. If two stacks truly need each other’s outputs, consider combining them into one (if feasible) or introducing an external orchestrator that handles the round-trip (not ideal). Often, it indicates the separation of stacks might need rethinking.

Examples:
	•	AWS: Suppose you have two AWS Lambda functions that trigger each other (as in a ping-pong example) or two security groups that reference each other. To resolve, deploy one function first and use its name in the second, or create both security groups without circular rules and add the mutual rule in a second pass. Pulumi’s guidance for the Lambdas was to utilize the stack’s outputs from the previous run ￼. Another example: an AWS ALB and an Auto Scaling Group might be interdependent (the ASG needs the ALB target group ARN, and the ALB health check might need the ASG instances). In practice, AWS allows these to be created in sequence; you’d make sure to create the ALB and target group first (ASG referencing it), then perhaps update health check after instances register. In Pulumi, you ensure the output of ALB TG is passed into ASG creation, breaking any cycle.
	•	Azure: The Application Gateway scenario is a known circular challenge. The Pulumi Azure Native provider currently recommends splitting the creation: create the Application Gateway resource with basic settings (maybe a dummy listener or no listener), then separately create the listener and link it to the gateway once the gateway exists ￼ ￼. This two-step deploy avoids the chicken-and-egg in the ARM API. Another Azure example could be Azure DNS and Azure CDN: if you tried to provision a CDN endpoint and a DNS record for it simultaneously, you’d ensure the CDN endpoint (which provides a hostname) is created first (Pulumi will handle this if you pass the endpoint’s output to the DNS record). True cycles in Azure resources are less common, but anything requiring circular references in ARM templates would surface similarly in Pulumi.
	•	GCP: Circular dependencies in GCP might be rarer, but imagine GCP Cloud Run services or Cloud Functions that call each other, or a scenario where a GCP resource needs a service account that in turn is created in the same config. Usually, you can create the service account first (no cycle). If you had two GCP services needing each other’s URLs or IDs, you’d apply the same approach: deploy one, then use its output for the other. Another possible cycle could be in network peering: if project A and project B each need a network peering to the other, you must initiate one side first then the other. Pulumi can handle network peerings by creating two resources (one for each side) with appropriate dependsOn to avoid trying both at the exact same time.

In summary, Pulumi itself does not allow unresolved circular dependencies – you must break them by design. Use techniques like sequential deployments or interim placeholders to resolve these situations. The Pulumi team has explored potential features to handle certain circular scenarios more gracefully (e.g., a way to declare a resource that updates itself after initial creation) ￼, but as of now the onus is on the user to break cycles. The key is to identify the cycle early (Pulumi’s preview will usually make it obvious) and then either restructure your code or perform a phased deployment.

4. Multi-Cloud and Large-Scale Considerations

Pulumi is multi-cloud by nature, meaning a single Pulumi program can manage resources across AWS, Azure, GCP, Kubernetes, etc. The dependency management core is the same, but there are a few considerations when dealing with multiple clouds or very large infrastructures.

Multi-Cloud Dependencies (Single Stack): In a single Pulumi stack, you can mix providers freely. For example, you might create an AWS EC2 instance and an Azure DNS record pointing to that instance’s public IP. Pulumi handles this seamlessly – if your Azure DNS record resource takes the EC2 instance’s IP output, Pulumi knows to create the EC2 instance first, then the DNS record, even though they are different providers. There’s nothing special needed beyond referencing outputs. You may need to configure multiple providers (one for AWS, one for Azure) or use provider options, but the dependency graph will include cross-cloud edges as needed. Provider-specific eventual consistency: Keep in mind that different clouds have different behaviors (e.g., AWS resources might be immediately available or eventually consistent, same for Azure/GCP). Pulumi doesn’t automatically wait for eventual consistency beyond the resource’s own provider signals. If a cloud’s API reports a resource is created but it’s not fully ready for use by another cloud’s resource, you may need to introduce a slight delay or retry logic. This is rare, but an example could be creating a GCP service account and immediately using it in AWS (usually the create call ensures it’s ready by the time it returns).

Dependencies Across Stacks (Inter-Stack): Often, large or multi-cloud projects are broken into multiple Pulumi stacks (for example, an AWS infra stack and an Azure infra stack). Pulumi supports this via Stack References, which let one stack read the outputs of another stack ￼. A StackReference is itself a resource that depends on the target stack’s latest state. For instance, you can have an Azure stack that does const awsStack = new pulumi.StackReference("org/proj/awsStack"); and then uses awsStack.getOutput("ec2Ip") as an input to an Azure resource (like a firewall rule). This creates an implicit dependency: the Azure resource will wait until that output value is known. However, note that StackReference reads the last deployed state of the other stack – it doesn’t actively run or update the other stack. Ensuring the other stack is up-to-date is up to you or your pipeline. In practice, you might run pulumi up on the AWS stack first, then on the Azure stack. Pulumi’s service and automation API have features to help coordinate stack updates (for example, Pulumi Deployments can automatically trigger dependent stack updates) ￼ ￼, but if you’re running manually or in CI, you must sequence them. The key is that StackReference provides a safe way to inject outputs from one stack into another, thereby linking their dependency graphs across stacks ￼. It allows multi-cloud orchestration while still keeping stacks isolated. One stack’s outputs are treated as read-only inputs in the consuming stack.

For example, you might separate networking and application into different stacks. The network stack (perhaps on AWS) exports a VPC ID and subnet IDs. The application stack (perhaps on GCP or another AWS region) can take those as inputs via a StackReference. This way, the app stack depends on the network stack’s outputs. Conceptually, treat cross-stack dependencies similar to function inputs/outputs – keep them minimal and necessary. Avoid circular references between stacks for the same reasons as above.

Large-Scale Projects (Organizing Stacks and Parallelism): As your infrastructure grows, you’ll likely manage hundreds or thousands of resources. Pulumi can handle large graphs, but build strategy around maintainability and performance:
	•	Organize into Multiple Stacks: It’s common to split a huge infrastructure into logical stacks – e.g., a base network stack, a database stack, an app stack, etc. This modular approach limits the size of each update and the blast radius of changes. Pulumi’s best practices suggest aligning stacks with logical boundaries (like different environments or tiers of your system) ￼. Multi-stack setups also allow different teams to work on different stacks in parallel (since each stack state is separate). Use StackReferences to connect them when necessary, but try to keep dependencies one-directional to avoid coordination nightmares.
	•	Use Component Resources for Reusability: Within a stack, if you have groups of resources that repeat or logically belong together, define them as a ComponentResource. This doesn’t directly reduce the number of resources, but it encapsulates complexity. For example, if you need to create 10 identical setups (across different regions or accounts), you might write a component and instantiate it 10 times. Each instance can be created in parallel if they don’t depend on each other. Components also let you apply parent to group sub-resources, which can improve the clarity of your dependency graph and outputs. Essentially, design your Pulumi project similar to software: break it into small, testable units.
	•	Parallelism and Resource Counts: By default Pulumi will try up to 16 parallel operations; you can adjust this with --parallel. For extremely large deployments (many hundreds of resources), you might increase this number to speed up deployments if your environment and provider APIs can handle it. Conversely, if you hit rate limits (e.g., AWS API throttling) you might dial it down slightly. Large-scale also means previews can become long; using targeted updates (with pulumi up --target) or refresh wisely can help, but those are more about state management than dependencies.
	•	Managing Dependencies in Multi-Cloud Scenarios: In multi-cloud architectures, different parts might be managed by different Pulumi projects. Make sure to document which stack outputs feed into which other stacks, so you have a clear understanding of order. Pulumi’s Cloud console (if using Pulumi SaaS) can show stack output values and could be used to manually ensure things are in sync. For truly large organizations, you might integrate Pulumi into a broader orchestration layer (like running all relevant stacks via a CI pipeline or using tools like Spinnaker, Cloud Deploy, etc., to coordinate). Pulumi doesn’t inherently know about dependencies across stacks unless you wire them with StackReferences and an external process triggers them in the right sequence.

In summary, multi-cloud deployments in one stack are straightforward – just use outputs to connect resources across providers. For large projects, split into stacks for manageability and use StackReferences to pass necessary data between them ￼. This decoupling also allows parallel development and easier scaling of your Pulumi runs. Always aim for a structure where each stack (or component) can be deployed independently, with minimal, well-defined inputs and outputs connecting them.

5. Best Practices and Anti-Patterns

Having looked at the mechanics, here are some best practices and common mistakes to avoid when structuring Pulumi dependencies:
	•	Leverage Implicit Dependencies: Pulumi excels at inferring dependencies from your code. The best practice is to use resource outputs whenever possible instead of hard-coding values. This naturally creates the correct graph. For example, if an EC2 instance needs the ID of a security group, pass the security group’s id output into the instance. Do not use a literal ID string or a lookup if you can pass the actual object; using outputs not only ensures correct order but also means Pulumi can re-run properly if the ID changes. As Pulumi’s documentation emphasizes, it automatically tracks dependencies when outputs are used as inputs ￼. Rely on that mechanism rather than workarounds.
	•	Use parent for Logical Grouping: Organize resources into a parent/child hierarchy that reflects real relationships (especially in component resources). This will make your Pulumi previews/updates easier to understand (you’ll see resources nested under their parent) and it inherits settings like providers and protection flags conveniently ￼ ￼. A good pattern is: if you write a ComponentResource (say a class that creates a cluster with nodes), mark all sub-resources with { parent: this }. This way, anyone using the component sees it as one logical unit. Also parent resources to components or stacks, not arbitrarily to other custom resources ￼. If you don’t specify a parent, Pulumi attaches the resource to the stack by default, which is fine for top-level resources. Just be mindful to set parents inside components (forgetting to do so is a common mistake that can lead to resources floating at the stack level instead of under the component).
	•	Minimize Use of dependsOn: In Pulumi, explicit dependsOn should be the exception, not the rule. Overusing dependsOn is considered an anti-pattern because it often indicates you’re manually enforcing an order that Pulumi might already handle, or that your design could be improved. Every explicit dependency potentially reduces parallelism. So use dependsOn only for scenarios where you must sequence things that Pulumi doesn’t know about ￼. For example, if you have a pulumi.Command resource that runs a script to initialize data after a database is up, you’d dependsOn the database resource. Or if using a cloud resource that is eventually consistent, you might add a dependsOn to give a buffer. But do not wrap your entire infrastructure in a single dependsOn chain. A bad anti-pattern would be something like:

const res1 = new Resource("res1", {/*...*/});
const res2 = new Resource("res2", {/*...*/}, { dependsOn: [res1] });
const res3 = new Resource("res3", {/*...*/}, { dependsOn: [res2] });
// ... and so on for no real reason

This defeats Pulumi’s ability to parallelize and usually isn’t needed. Instead, only link resources that truly depend on each other’s existence or side effects. Remember, if resource res3 needed res1 and res2’s outputs, you’d already have implicit deps. If it doesn’t, then let Pulumi deploy res3 independently. In essence, don’t serialize your graph unnecessarily.

	•	Avoid Creating Resources in .apply Callbacks: This is a subtle but important anti-pattern. An .apply on an Output is meant for transforming values, not initiating new resources. If you attempt to create a resource inside an apply (for example, after reading some file or waiting for some output), Pulumi will not properly track that resource in the graph, and it’s disallowed in most Pulumi languages ￼. The correct approach is to rearrange code so that resource creation is top-level. If you need to wait for some outputs to create another resource, you can often use pulumi.all([...]).apply(...) to combine outputs and still return a value that is used in a resource definition, or use a ComponentResource to perform an ordered sequence. The Stack Overflow example of generating an API Gateway spec after getting Cloud Run URLs is a case where the solution was to use a ComponentResource rather than create the gateway inside an apply ￼. Think declaratively: all resources should be declared by the time the Pulumi program finishes running, so the engine knows about them. Using dependsOn or outputs will ensure the ordering without resorting to hidden imperative creation.
	•	Don’t abuse global variables or external state for ordering: Sometimes newcomers try to use external flags or sleep timers to coordinate resource creation. For example, one might think “call await new Resource() in code before proceeding to the next – that’s not how Pulumi works. The Pulumi program should ideally just declare resources (without awaiting their completion in the code flow). Let Pulumi do the waiting via the dependency graph. Using setTimeout or other tricks to delay creation of a resource is unreliable and not needed. Instead, express the dependency relationships and let Pulumi handle timing.
	•	Be careful with partial updates and pulumi refresh: While not directly about dependency graph, using pulumi refresh or targeting individual resources (pulumi up --target) can, if used incorrectly, break assumptions. For instance, deleting a resource out-of-band and then running refresh can confuse dependencies. Always ensure that if you remove or import resources manually, the dependencies are re-established properly in code. This is more about state management, but it intersects with dependency correctness.
	•	Minimize Circular References: As discussed, design outputs and inputs to avoid cycles. If you suspect a circular requirement, resolve it by splitting the deployment or refactoring. A code smell is if two resources each take an output from the other – step back and think how to redesign that (maybe combine into one resource if possible, or use one as config for the other).
	•	Optimize Deployment Speed Thoughtfully: To speed up Pulumi operations while maintaining correctness, do the following: Keep resources independent unless there’s a good reason to link them. This maximizes parallel creation. Group related things in components to limit widespread dependencies. For example, if you have 10 microservices, each with its own infra, encapsulate each in a component. If none of them depend on each other, Pulumi can deploy all 10 components in parallel. Within each component, you might have some sequential steps, but that doesn’t slow down others. Also leverage Pulumi features like parallelism flag if needed. On the flip side, be mindful of provider rate limits; sometimes a slightly slower deployment is better than hitting an API throttle (this might mean introducing a tiny dependency or limiting parallelism in extreme cases).
	•	Testing and Visualizing Dependencies: A best practice is to test your Pulumi stack in preview and even use the pulumi graph (or pulumi stack graph) command to output the dependency graph (in DOT format) for complex stacks ￼. This can help you verify there are no unexpected dependencies or missing ones. If you see resources executing in the wrong order, check if you forgot to pass an output or set a necessary dependsOn. Likewise, if everything is strictly serial and slow, check if you added an unneeded parent or dependsOn linking them.
	•	Cleaning Up with parent and deletedWith: Another practice: if you have ephemeral resources (like temporary infra for a test), consider using the deletedWith option or appropriate parent so that when the parent is destroyed, the child is automatically cleaned up ￼. This ensures no dangling resources. For example, if a temporary bucket should be deleted when a compute instance is deleted, making the instance the parent of the bucket (if logical) or at least using dependsOn for deletion ordering can help.
	•	ComponentResource Dependencies: If you have large components and you want to ensure one component finishes before another begins (perhaps they represent distinct subsystems), you can use dependsOn at the component level. For example, new MyApp("app", {...}, { dependsOn: network }) if network is a ComponentResource representing the network setup. However, note that currently a dependsOn on a component may not automatically wait on all internal children (there was an issue about this) – the safe bet is to depend on an output of the component (since outputs aren’t available until the component’s children are done). Export something like isReady from the component (or just any output from one of its main resources) and use that as an implicit dependency in the other component. This pattern avoids any surprise where dependsOn might not account for nested resources.
	•	Secrets and Outputs: Not directly dependency-related, but ensure if you pass outputs between stacks (StackReference), handle secrets properly (Pulumi will keep them encrypted). And if you rely on outputs for dependencies, those outputs should be as minimal as needed (e.g., output an ID string, not an entire resource object which might not serialize as you expect).

Summary of Anti-Patterns: Avoid unnecessary dependsOn, avoid misusing parent, don’t try to force an imperative execution order, and don’t create resources in Output callbacks. These are all things that either break Pulumi’s model or hinder its performance. Instead, embrace the declarative style: declare resources with their relationships, and let Pulumi figure out the rest. As one Pulumi engineer succinctly put it, resource options like parent and dependsOn are for things “Pulumi can’t figure out on its own” ￼ – use them for that purpose and no more. Following these practices will lead to cleaner, more efficient Pulumi programs that deploy infrastructure correctly and quickly.

References:
	1.	Pulumi Docs – Resource Options: dependsOn ￼ and parent ￼ ￼ (usage and guidelines)
	2.	Pulumi Docs – How Pulumi Works (Dependency graph and parallel execution) ￼
	3.	Stack Overflow – How to control resource creation order in Pulumi (M. Shilkov’s example of implicit vs explicit dependency) ￼ ￼
	4.	Pulumi Blog – Exploring how to solve circular dependencies (Ping/Pong example and StackReference workaround) ￼ ￼
	5.	Pulumi GitHub Issue – Azure Application Gateway circular dependency (discussion of two-phase deployment) ￼
	6.	Stack Overflow – Pulumi strict dependency order (recommendation to use ComponentResource instead of apply for sequencing) ￼
	7.	Pulumi Concepts – Stacks and StackReference (using outputs from one stack in another) ￼ ￼
	8.	Pulumi CLI Reference – pulumi up --parallel option (default parallelism is 16) ￼
	9.	Community Advice – Pulumi best practices on parent vs dependsOn (use parent frequently, dependsOn sparingly)
